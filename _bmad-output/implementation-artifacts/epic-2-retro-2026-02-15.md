# Epic 2 Retrospective - Polymarket Connectivity & Cross-Platform Data

**Date:** 2026-02-15
**Epic:** Epic 2 (Stories 2.1 - 2.4)
**Facilitator:** Bob (Scrum Master)
**Participant:** Arbi (Project Lead)

## Epic Summary

**Delivery Metrics:**
- **Completed:** 4/4 stories (100%)
- **Test Coverage:** Comprehensive (249 tests passing at completion)
- **Technical Debt:** 3 items deferred (gas estimation, async confirmation methods, encrypted keystore)
- **Production Incidents:** 0

**Stories Delivered:**
1. Story 2.1: Polymarket Connector & Wallet Authentication âœ…
2. Story 2.2: Polymarket Order Book Normalization âœ…
3. Story 2.3: Cross-Platform Data Aggregation & Health Dashboard âœ…
4. Story 2.4: Graceful Degradation & Automatic Recovery âœ…

**Business Outcomes:**
- âœ… Complete Polymarket connectivity established (CLOB REST + WebSocket)
- âœ… Cross-platform data aggregation operational (Kalshi + Polymarket)
- âœ… Health monitoring with graceful degradation
- âœ… Ready for Epic 3 (Arbitrage Detection)

## Sprint 0 Reconciliation

### What We Planned (Epic 1 Retrospective)

Epic 2 Sprint 0: 7 tasks over 4 days with formal gates and team coordination

1. Design IAuthProvider abstraction
2. Extend IPlatformConnector to v1.1 (async confirmation methods)
3. Refactor KalshiConnector with ApiKeyAuthProvider
4. **Epic 1 full regression testing (NON-NEGOTIABLE gate)**
5. Polymarket order flow proof-of-concept (2 days)
6. MockChainProvider implementation (Dana + Elena pairing)
7. Team knowledge share session

### What Actually Happened

**âœ… Executed:**
- **Regression gate:** Full Epic 1 test suite passed before Epic 2 began (foundation validated)

**âŒ Invalidated by SDK Adoption:**
1. **IAuthProvider abstraction** â†’ Not needed (SDK handles auth internally)
3. **KalshiConnector refactor** â†’ Pointless (no shared abstraction to extract)
5. **Polymarket POC** â†’ Merged into Story 2.1 implementation (just-in-time discovery)

**SDK Decision Cascade:**
- Polymarket CLOB REST integration more complex than anticipated (auth, signing, nonce management)
- Adopted `@polymarket/clob-client` SDK instead of manual viem implementation
- **Result:** SDK became the auth layer, eliminating need for IAuthProvider abstraction

**âŒ Deferred with Rationale:**
2. **IPlatformConnector v1.1 async methods** â†’ Deferred to Epic 5
   - **Rationale:** Polymarket orders = off-chain CLOB (synchronous REST, same as Kalshi)
   - On-chain transactions (deposits/withdrawals/settlement) = Epic 5 scope
   - `confirmTransaction()` and `getTransactionStatus()` not needed for MVP order placement

**âŒ Not Needed:**
6. **MockChainProvider** â†’ Not applicable for current scope
   - **Mocking strategy:** SDK-level mocks (`@polymarket/clob-client`, `@ethersproject/wallet`, `ws`)
   - No chain RPC calls in current code â†’ no chain provider to mock
   - Simple, targeted mocking sufficient for MVP

**âŒ Not Applicable:**
7. **Knowledge share session** â†’ Solo project
   - Team roles in planning docs = structural thinking, not actual people
   - Arbi is solo implementer

### Sprint 0 Learning: "Spike When Uncertain, Discover When Familiar"

**Pattern Identified:**
- **Epic 1 â†’ Epic 2 Transition:**
  - Epic 1: First platform (Kalshi) = high uncertainty â†’ justified Sprint 0 spike
  - Epic 2: Second platform (Polymarket) = moderate uncertainty â†’ Sprint 0 over-planned

**What We Learned:**
- Don't design abstractions before you have 2+ concrete implementations to abstract from
- SDK adoption decisions invalidate architectural assumptions (embrace the pivot!)
- Just-in-time discovery works when the domain is moderately familiar
- Formal spikes are for **paradigm shifts**, not **incremental expansion**

**New Heuristic:**
- **First platform in new category:** Do Sprint 0 spike
- **Second platform in same category:** Discover during implementation
- **Third+ platform:** Abstraction patterns should be obvious by now

**Conclusion:** We executed critical parts (regression gate) and correctly skipped premature parts (abstractions before second implementation). This is **mature engineering judgment**, not a process violation.

## What Went Well

### Technical Execution Wins

**1. Polymarket Decimal Price Discovery** ðŸŽ¯
- Story 2.2 discovered Polymarket prices already decimal (0.00-1.00)
- **~50x faster normalization** than Kalshi (no division overhead)
- Simplified code, improved performance, reduced float precision risk

**2. Defensive Null Pattern Established** ðŸ›¡ï¸
- Story 2.2: Comprehensive NaN validation, null/undefined safety
- Story 2.3: `toPlatformEnum()` utility for safe enum conversion
- **Impact:** Zero runtime crashes from malformed API data

**3. No-Separate-Cron Decision** ðŸ§ 
- Story 2.4: Polling fallback called from existing cron (NOT separate cron job)
- **Impact:** Avoided cron proliferation, simpler architecture

**4. Platform Enum Migration** ðŸ”„
- Story 2.2: Migrated to uppercase KALSHI/POLYMARKET in DB
- **Impact:** Consistent with TypeScript enums, cleaner type safety

**5. Architecture Compliance Maintained** âœ…
- Story 2.3: Proper DI injection (PolymarketConnector â†’ DataIngestionService)
- Story 2.3: Added SystemHealthError (codes 4000-4999) to hierarchy
- **Impact:** Zero architectural violations despite 4 stories

**6. Testing Discipline Unbroken** ðŸ’ª
- 249 tests passing at Epic completion (100% continuity from Epic 1)
- Comprehensive code review on all stories
- No quality regression

### Pragmatic Technical Decisions

**7. SDK Adoption Over Manual Implementation**
- Used `@polymarket/clob-client` instead of manual REST/viem implementation
- **Impact:** Reduced complexity, faster delivery, battle-tested auth

**8. Static Gas Estimates Acceptable for MVP**
- Polygon gas ($0.01-0.10) negligible vs 0.8%+ edges
- Deferred precision to Epic 5
- **Impact:** Avoided premature optimization

**9. Mocking at SDK Level**
- Mocked `@polymarket/clob-client`, `@ethersproject/wallet`, `ws` directly
- Simpler than HTTP/chain-level mocking
- **Impact:** Faster tests, easier maintenance

### Process Maturity

**10. Regression Gate Executed**
- Full Epic 1 test suite passed before Epic 2 began
- Foundation validated, no silent regressions

**11. Appropriate Sprint 0 Tasks Skipped**
- Avoided premature abstraction (IAuthProvider)
- Pragmatic pivot when SDK adoption changed assumptions

**12. Just-In-Time Discovery**
- Worked for moderately familiar domain (second platform integration)

## Challenges & Learnings

### 1. Sprint 0 Documentation Gap

**Challenge:** Regression gate executed but not documented in story files, SDK decision rationale not captured until retrospective

**Learning:** Document **why** we deviate from plans, not just **what** we delivered

**Action:** Add "Decision Log" section to story files when deviating from planned approach (Action Item #1)

### 2. Solo Project Realism

**Challenge:** Epic 1 retro made team-based commitments (pairing, knowledge shares, multi-person reviews), but Arbi is solo implementer

**Learning:** Tailor process to actual team structure

**Action:** Remove team-based commitments from future retrospectives (Action Item #3)

### 3. Architectural Assumption Churn

**Challenge:** Epic 1 planned IAuthProvider abstraction based on assumption of manual auth implementation; Epic 2 invalidated this when SDK adoption happened

**Impact:** 12 hours of planning work (Epic 1 Sprint 0 design time) wasted

**Learning:** Don't abstract until you have 2+ concrete implementations

### 4. Technical Debt Tracking

**Challenge:** Epic 1 had formal technical debt inventory (3 items tracked); Epic 2 has informal deferrals (gas estimation, async confirmation methods)

**Impact:** No centralized view of deferred work

**Learning:** Maintain technical debt register across epics

**Action:** Create `technical-debt.md` register (Action Item #2)

## Key Insights

**1. Abstractions Emerge, They Aren't Predicted**
- IAuthProvider seemed necessary before Polymarket integration
- SDK adoption made it unnecessary
- **Lesson:** Wait for pain before adding abstraction layers

**2. Just-In-Time Discovery Works for Incremental Expansion**
- Epic 1 (first platform) justified formal spike
- Epic 2 (second platform) worked with in-flight discovery
- **Lesson:** Adjust spike rigor to uncertainty level

**3. Regression Gates Are Non-Negotiable, Spikes Are Negotiable**
- Regression gate: Executed (foundation validated)
- Sprint 0 architectural tasks: Skipped/deferred (pragmatic pivot)
- **Lesson:** Separate "must-haves" from "planned work" explicitly

**4. Testing Strategy Evolves With Integration Patterns**
- Epic 1: Mock at HTTP/WebSocket level (Kalshi SDK has gaps)
- Epic 2: Mock at SDK level (Polymarket SDK is complete)
- **Lesson:** Mocking strategy should match SDK maturity

**5. Performance Discoveries Matter**
- Polymarket decimal prices â†’ 50x faster normalization
- Small discoveries compound across system lifecycle

## Technical Debt Inventory

### Deferred to Epic 5
1. **Dynamic Gas Estimation** (Priority: Medium)
   - Current: Static conservative estimate ($0.10-0.50)
   - Future: Dynamic estimation via viem for Polymarket on-chain transactions
   - **Owner:** Arbi | **Timeline:** Epic 5 (execution module)

2. **IPlatformConnector Async Confirmation Methods** (Priority: Medium)
   - Current: Off-chain CLOB orders (synchronous confirmation)
   - Future: `confirmTransaction(txHash)`, `getTransactionStatus(txHash)` for on-chain settlement
   - **Owner:** Arbi | **Timeline:** Epic 5 Sprint 0

### Deferred to Epic 11
3. **Encrypted Keystore for Polymarket Wallet** (Priority: Low - security hardening)
   - Current: Direct private key in environment variables
   - Future: Encrypted keystore with passphrase
   - **Owner:** Arbi | **Timeline:** Epic 11 (security hardening)

## Epic 3 Preparation Plan

### Readiness Assessment

**Status:** Ready with Minimal Sprint 0

**Pre-Flight Audit (Arbi):**
1. âœ… **Fee schedule interface** - `getFeeSchedule()` exists on `IPlatformConnector`, both connectors implement it
2. âœ… **Gas estimates** - Static conservative estimate acceptable for MVP (Polygon gas negligible vs. 0.8%+ edges)
3. ðŸ”¨ **Detection cycle algorithm** - To build in Story 3.2 (event-driven with polling fallback, Promise.all parallel checking)
4. ðŸš¨ **Financial calculation testing** - Critical gap, Story 3.3 must include rigorous test coverage
5. âš ï¸ **Config validation** - Minimal today, Story 3.1 should add class-validator DTOs and Zod validation
6. âš ï¸ **Migration rollback** - No plan, need companion down-migrations and rollback testing

### Epic 3 Sprint 0 (9 hours - Minimal Targeted Prep)

**Why NOT a Full Sprint 0:**
- Detection module builds on proven infrastructure (order books, events, health monitoring)
- Financial calculations are complex but well-defined (not paradigm shift)
- Config management is straightforward (YAML + class-validator)
- Database migration is low-risk (no foreign keys from later epics yet)

**Why We DO Need Targeted Prep:**
- Financial calculation correctness is **critical** (0.8% threshold precision matters)
- Test strategy for edge cases needs upfront design
- `decimal.js` adoption should happen before Story 3.3

**Task 1: Financial Math Test Design (4 hours)**
- **Owner:** Arbi
- **Output:** 10-15 hand-verified edge calculation scenarios (CSV format)
  - Exact threshold cases (0.79%, 0.80%, 0.81%)
  - Fee interaction cases (high fee vs. low fee platforms)
  - Gas cost impact (negligible vs. significant)
  - Negative edge cases (no arbitrage opportunity)
  - Extreme spreads (>5% edge)
- **Purpose:** Story 3.3 tests must match these hand-verified scenarios

**Task 2: Decimal.js Setup (2 hours)**
- **Owner:** Arbi
- **Action:** Install `decimal.js`, create `FinancialMath` utility module
- **Output:** Stubbed methods using Decimal type:
  - `calculateNetEdge(prices, fees, gas): Decimal`
  - `calculateGrossEdge(prices): Decimal`
  - `applyFees(edge, feeSchedule): Decimal`
- **Note:** Decision already made (IEEE 754 inadequate for 0.8% precision)

**Task 3: Config Schema + Rollback Strategy (3 hours)**
- **Owner:** Arbi
- **Output 1:** YAML schema for contract pairs + class-validator DTO
  - Fields: `polymarketContractId`, `kalshiContractId`, `eventDescription`, `operatorVerificationTimestamp`
  - Validation: Required fields, no duplicates, timestamp format
- **Output 2:** Companion down-migrations for `contract_matches` and `match_approval_logs` tables
- **Output 3:** Test rollback in local Docker
- **Purpose:** Story 3.1 uses schema, Story 3.4 uses migration, rollback validated before production

**Gate:** All Sprint 0 outputs (test scenarios, decimal.js utility, config schema, rollback migrations) complete before Epic 3 stories begin.

### Critical Epic 3 Risk: Detection Without Execution

**The Gap Risk:**
- Epic 3 builds detection logic and edge calculation
- Epic 5 builds order execution (2 epics later)
- **Problem:** Can't validate signal quality until Epic 5 when real orders execute

**Concrete Failure Modes:**
1. **False positive:** Detection says 1.2% edge exists, but real market has moved â†’ order fails in Epic 5
2. **Edge miscalculation:** Fee accounting wrong, thinks 0.9% edge, actually 0.5% after all costs â†’ unprofitable trade
3. **Liquidity misjudgment:** Edge exists at shown price, but depth insufficient â†’ partial fill, worse average price
4. **Timing issues:** Detection cycle finds opportunity, but by time Epic 5 executes, it's gone

**Why This Is Critical:**
- Epic 3's value = **signal quality** (accurate detection, correct edge calculation)
- Normal technical debt = known shortcuts, documented for later
- **This debt = unknown correctness** â€” you don't know if detection works until 2 epics later

**Mitigation Strategy:**

**1. Story 3.3 Acceptance Criteria Enhancement:**
- All 15 hand-verified scenarios pass with exact expected output
- Property-based tests verify edge calculation is commutative, associative, and monotonic
- Fuzz testing with 1000 random price/fee combinations, no NaN/Infinity results
- 5 real contract pairs validated against manual spreadsheet calculation

**2. Epic 3 Completion Criteria (Dry-Run Validation):**
- Run detection engine against live order books for 48 hours (no execution)
- Log all opportunities
- Manually verify 20-30 logged opportunities match real market conditions
- **Gate:** <5% false positive rate, edge calculations match manual verification within 0.01%
- If discrepancies found, fix before Epic 4

**3. Epic 3 â†’ Epic 4 â†’ Epic 5 Dependency Chain:**
- Epic 3: Detection + edge calculation
- Epic 4: Risk management (depends on Epic 3 edge accuracy)
- Epic 5: Execution (depends on Epic 3 detection + Epic 4 risk validation)

## Action Items

### Process Improvements

**1. Document Decision Rationale in Story Files**
- **Owner:** Arbi
- **Action:** When deviating from planned approach, add "Decision Log" section to story file with:
  - What was planned
  - What was actually done
  - Why the change was made
  - What assumptions were invalidated
- **Deadline:** Ongoing, starting Epic 3
- **Success Criteria:** Every Epic 3 story file has "Decision Log" if deviations occurred

**2. Maintain Technical Debt Register**
- **Owner:** Arbi
- **Action:** Create `_bmad-output/implementation-artifacts/technical-debt.md` with table:
  - Item | Deferred From | Deferred To | Rationale | Priority | Owner
- **Items to Add:**
  - Gas estimation (deferred from Epic 2 to Epic 5)
  - IPlatformConnector async methods (deferred to Epic 5)
  - Encrypted keystore (deferred to Epic 11)
- **Deadline:** Before Epic 3 Sprint 0
- **Success Criteria:** Central register exists, updated after each epic

**3. Tailor Retrospective Format for Solo Project**
- **Owner:** Bob (Scrum Master)
- **Action:** Remove team-based commitments from future retrospectives:
  - No pairing tasks
  - No knowledge sharing sessions
  - No multi-person reviews
  - Keep: Testing discipline, architectural compliance, decision documentation
- **Deadline:** Epic 3 retrospective
- **Success Criteria:** Epic 3 retro has solo-appropriate commitments only

**4. Explicit Sprint 0 Gate Definition**
- **Owner:** Arbi + Bob
- **Action:** For each epic requiring Sprint 0, define gates as:
  - **Must-Execute:** Gates that block epic start (e.g., regression testing)
  - **Conditional:** Tasks that can be skipped/deferred with rationale (e.g., abstractions, spikes)
- **Deadline:** Epic 3 Sprint 0 plan (defined in this retrospective)
- **Success Criteria:** Clear separation of "must-haves" vs. "planned work"

### Epic 3 Preparation

**5. Execute Epic 3 Sprint 0 (9 hours)**
- **Owner:** Arbi
- **Tasks:**
  1. Financial math test design (4h)
  2. Decimal.js setup (2h)
  3. Config schema + rollback strategy (3h)
- **Gate:** All outputs complete before Epic 3 Story 3.1 begins
- **Deadline:** Before Epic 3 Sprint 1

**6. Add Dry-Run Validation to Epic 3 Completion Criteria**
- **Owner:** Arbi
- **Action:** Run detection engine against live order books for 48 hours (no execution), manually verify 20-30 opportunities
- **Acceptance:** <5% false positive rate, edge calculations match manual verification within 0.01%
- **Deadline:** Before Epic 4 begins
- **Purpose:** Validate signal quality before building risk management on top

**7. Enhance Story 3.3 Test Coverage**
- **Owner:** Arbi
- **Action:** Add to Story 3.3 acceptance criteria:
  - All 15 hand-verified scenarios pass exactly
  - Property-based tests (commutativity, associativity, monotonicity)
  - Fuzz testing (1000 random inputs, no NaN/Infinity)
  - 5 real contract pairs validated against manual spreadsheet
- **Deadline:** Story 3.3 completion
- **Purpose:** Catch edge calculation bugs before Epic 5

## Retrospective Commitments

### What We Learned

- **Abstractions emerge from concrete implementations** â€” don't design them prematurely
- **Just-in-time discovery works for incremental expansion** â€” spikes are for paradigm shifts
- **SDK adoption decisions invalidate architectural assumptions** â€” embrace the pivot
- **Regression gates are non-negotiable, architectural spikes are negotiable**
- **Testing discipline maintained** â€” 249 tests, 100% delivery rate, zero quality regression
- **Performance discoveries matter** â€” small wins (decimal prices) compound over time

### What We'll Do Differently

- **Document decision rationale** when deviating from plans
- **Maintain technical debt register** across epics
- **Dry-run validate detection** before building execution on top
- **Property-based + fuzz testing** for financial calculations
- **Explicit gate definitions** (must-execute vs. conditional)

### What We'll Keep Doing

- **Comprehensive dev notes** for each story
- **Regression testing** before starting new epics
- **Architecture compliance** (clean DI, error hierarchy, module boundaries)
- **Pragmatic technical decisions** (SDK over manual, static over dynamic when acceptable)
- **Defensive programming** (NaN validation, null safety, type guards)

## Team Acknowledgment

Epic 2 delivered:
- 4 stories with 100% completion
- Comprehensive testing maintained (249 tests passing)
- Cross-platform data aggregation operational (Kalshi + Polymarket)
- Graceful degradation and automatic recovery
- Zero production incidents

**Performance:** Excellent. All commitments met, quality maintained, ready for Epic 3.

## Next Steps

1. **Execute Epic 3 Sprint 0** (9 hours)
   - Complete all 3 preparation tasks
   - Pass gate before Epic 3 stories begin

2. **Begin Epic 3 Sprint 1** (after Sprint 0 completion)
   - Story 3.1: Manual Contract Pair Configuration
   - Rigorous testing foundation in place

3. **Dry-Run Validation** (after Epic 3 story completion)
   - 48-hour detection against live markets
   - Validate signal quality before Epic 4

---

**Retrospective Status:** âœ… Complete
**Epic 2 Status:** âœ… Delivered
**Epic 3 Readiness:** Ready with Minimal Sprint 0 (9 hours)
**Next Milestone:** Epic 3 Sprint 0 (before Epic 3 Sprint 1)
